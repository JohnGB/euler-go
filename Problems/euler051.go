/*
By replacing the 1st digit of the 2-digit number *3, it turns out that six of
the nine possible values: 13, 23, 43, 53, 73, and 83, are all prime.

By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit
number is the first example having seven primes among the ten generated
numbers, yielding the family: 56003, 56113, 56333, 56443, 56663, 56773, and
56993. Consequently 56003, being the first member of this family, is the
smallest prime with this property.

Find the smallest prime which, by replacing part of the number (not
necessarily adjacent digits) with the same digit, is part of an eight prime
value family.
*/

package main

import (
	"fmt"
	"strconv"
	"strings"
	"time"
)

var p = fmt.Println
var pf = fmt.Printf

// timeTrack is used for basic benchmarking in other functions
func timeTrack(start time.Time, name string) {
	elapsed := time.Since(start)
	fmt.Printf("%s took %s \n", name, elapsed)
}

func primeMap(max int) map[int]bool {
	// defer timeTrack(time.Now(), "primeMap") // Timer function

	sieve := make([]bool, max/2+1)
	// initialise the prime list with the only even prime
	primeMap := map[int]bool{2: true}

	// 3 is the first odd prime
	for i := 3; i <= max; i += 2 {
		if sieve[i/2] == false {
			// i should be a prime number, so add to list of primes
			primeMap[i] = true
			// any odd * even = even, so avoid all even multiples
			for j := 3; i*j <= max; j += 2 {
				sieve[i*j/2] = true
			}
		}
	}
	return primeMap
}

// This method generates all numbers that could be used to substitute the 1's
// for other numbers, and checks them for the lowest value one that satisfies
// the condition.  lim = the limit of the number that you want to check to,
// and 'count' = the family number.  For this problem, count should = 8
func findSmallestPrimeFamilyPrime(lim, count int) int {
	defer timeTrack(time.Now(), "findSmallestPrimeFamilyPrime()")

	// we need to be sure that the prime map will cover all the number
	// replacements up to 'lim'.  If lim is always of the form 99999, then we
	// don't need it, but if lim were 10000 instead, we would
	// primes := primeMap(lim * 10)
	primes := primeMap(lim)

	// takes in the number 'n' and a string 'c' of the digit to replace.
	// Returns the count of primes generated by replacing the digit 'c' and
	// the lowest prime of the generated digits
	replaceZerosAndCountPrimes := func(n int, c string) (int, int) {

		str0 := strconv.Itoa(n)

		countNonPrimes := 0
		lowestPrime := 99999999

		for i := 0; i <= 9; i++ {
			digitString := strconv.Itoa(i)
			newString := strings.Replace(str0, c, digitString, -1)
			// if there is a leading '0' after the replacement, don't add to the list of results
			if newString[0] == '0' {
				countNonPrimes++
				continue
			}
			newInt, _ := strconv.Atoi(newString)

			if primes[newInt] == false {
				countNonPrimes++
				if countNonPrimes == 10-count+1 {
					return 0, 0
				}
			} else {
				if newInt < lowestPrime {
					lowestPrime = newInt
				}
			}
		}
		return (10 - countNonPrimes), lowestPrime
	}
	// needs at least 3 digits and can't be even
	for i := 11; i < lim; i += 2 {

		primecount, lowestPrime := replaceZerosAndCountPrimes(i, "1")
		if primecount == count {
			return lowestPrime
		}
	}
	return 0
}

func main() {

	// p(replaceZerosAndCountPrimes1("020303"))
	// p(replaceZeros(1003))
	// p(primeMap(100))
	p(findSmallestPrimeFamilyPrime(999999, 8))

}
