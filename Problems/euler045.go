/*
Triangle, pentagonal, and hexagonal numbers are generated by the following
formulae:

Triangle	 	Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Pentagonal	 	Pn=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	Hn=n(2n−1)	 	1, 6, 15, 28, 45, ...
It can be verified that T285 = P165 = H143 = 40755.

Find the next triangle number that is also pentagonal and hexagonal.
*/

/*JGB: Can also be solved mathematically with BASIC code:
n = 1
do
  n=n+1
  h=n*(2*n-1)
  k=(1+math.sqrt(1+24*h))/6
  if k=int(k) then msgbox(h)
loop*/

package main

import (
	"fmt"
	"time"
)

var p = fmt.Println
var pf = fmt.Printf

// timeTrack is used for basic benchmarking in other functions
func timeTrack(start time.Time, name string) {
	elapsed := time.Since(start)
	fmt.Printf("%s took %s \n", name, elapsed)
}

func makePentMap(start, end int) map[int]bool {

	pentMap := make(map[int]bool)
	for n := start; n <= end; n++ {
		pentMap[n*(3*n-1)/2] = true
	}
	return pentMap
}

func makeHexMap(start, end int) map[int]bool {

	hexMap := make(map[int]bool)
	for n := start; n <= end; n++ {
		hexMap[n*(2*n-1)] = true
	}
	return hexMap
}

func findNextTriPentHex1() int {
	defer timeTrack(time.Now(), "findNextTriPentHex1()")

	const END = 100000

	pentMap := makePentMap(166, END)
	hexMap := makeHexMap(144, END)

	for n := 286; n <= END; n++ {
		triNum := n * (n + 1) / 2
		if pentMap[triNum] == true && hexMap[triNum] == true {
			return triNum
		}
	}
	return -1
}

// JGB: much faster solution
func findNextTriPentHex2() int {
	defer timeTrack(time.Now(), "findNextTriPentHex2()")

	const END = 100000

	pentMap := makePentMap(166, END)

	// using the fact that all hex numbers are also triangle numbers we can
	// ignore the triangle numbers
	for n := 144; n <= END; n++ {
		hexNum := n * (2*n - 1)
		if pentMap[hexNum] == true {
			return hexNum
		}
	}
	return -1
}

func main() {
	p(findNextTriPentHex1())
	p(findNextTriPentHex2())
}
